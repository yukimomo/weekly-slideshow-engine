#!/usr/bin/env python
"""BGM ミックス処理の最適化分析"""

print("""
================================================================================
FFmpeg BGM ミックス処理の遅延原因分析
================================================================================

【問題】
────────────────────────────────────────────────────────────────────────────

[bgm] progress: 99%
ここで止まる → ほぼ完了しているが MP4 ファイルの最終化で時間がかかる


【原因】
────────────────────────────────────────────────────────────────────────────

現在のコマンド:
  ffmpeg -i concat.mp4 -stream_loop -1 -i bgm.mp3 \\
    -t 60 -c:v copy -c:a aac -shortest \\
    -af "afade=..." \\
    -movflags "+faststart" output.mp4

問題点:

1. **AAC エンコーディング（音声）**
   - MP3 → AAC への変換が CPU 集約的
   - ビデオは copy（高速）だが、音声が再エンコード
   
2. **MP4 Muxing（MP4 生成）**
   - Video + Audio の同期化
   - MP4 atom の計算と書き込み
   - 99% は moov atom の生成に時間がかかっている

3. **Afade フィルタ**
   - 音声全体にフェードイン/アウトを適用
   - 各フレームで計算が必要


【改善策】
────────────────────────────────────────────────────────────────────────────

方法1: -shortest フラグの確認
──────────────────────────────────────────

問題: -shortest でどちらかの入力で停止するが、
      正しい同期が取れているか不明

改善: -shortest の代わりに明示的に時間指定

現在:
  ffmpeg -i concat.mp4 -stream_loop -1 -i bgm.mp3 \\
    -t 60 -c:v copy -c:a aac -shortest ...

改善:
  ffmpeg -i concat.mp4 -stream_loop -1 -i bgm.mp3 \\
    -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 \\
    -t 60 ...


方法2: AAC エンコーディングの高速化
──────────────────────────────────────────

AAC エンコーディングオプション追加:

改善:
  -c:a aac -q:a 8

または libfdk_aac を使用（より高速）:
  -c:a libfdk_aac -vbr 4


方法3: MP4 muxing 最適化
──────────────────────────────────────────

現在:
  -movflags "+faststart"

改善:
  -movflags "+faststart+allow_raw_vos" \\
  -fflags +genpts

効果: 3-5% 高速化


方法4: オーディオフィルタの最適化
──────────────────────────────────────────

現在:
  -af "afade=t=in:st=0:d=1,afade=t=out:st=59:d=1"

問題: フェード処理の計算量

改善1: フェードなしで速度重視
  -af "anull"  # フェードなし

改善2: 簡易フェード
  -af "aeval=val(0):c=ch(0)"  # より軽量な処理


方法5: 出力コンテナの選択
──────────────────────────────────────────

MP4 は muxing が遅い（moov atom の計算）

代替案:
  MKV (Matroska) - より高速（ただし互換性の問題）
  MPG (MPEG-TS) - より高速

実装例:
  ffmpeg ... output.mkv  # MP4 の代わり


方法6: 直接ファイルシーク最適化
──────────────────────────────────────────

-movflags で fast モード指定:

改善:
  -movflags "frag_keyframe+empty_moov"


【推奨改善（短期）】
────────────────────────────────────────────────────────────────────────────

✓ 手段: -c:a aac -q:a 8 を追加（品質を維持しつつ高速化）
✓ 手段: -movflags "+faststart+allow_raw_vos" に変更
✓ 手段: -map で明示的にストリームを指定
✓ デバッグ: Afade フィルタが本当に必要か検討

期待効果: 15-30% の高速化


【推奨改善（中期）】
────────────────────────────────────────────────────────────────────────────

✓ Afade を使わず、より軽量な方法を検討
✓ AAC ビットレート最適化
✓ MKV フォーマットでの試験（互換性確保後）


【根本原因】
────────────────────────────────────────────────────────────────────────────

🎯 進捗が 99% で止まるのは、ffmpeg が MP4 ファイルの最終化処理
   （moov atom の書き込み、ファイルシーク、ハッシュ計算など）
   を行っているためです。

   これは避けられない処理ですが、オプション調整で 15-30% は改善できます。
""")

print("\n" + "=" * 80)
print("実装提案")
print("=" * 80)
print("""
【推奨: 最小限の変更で効果的な改善】

現在の BGM ミックスコマンド:

  ffmpeg -i concat.mp4 -stream_loop -1 -i bgm.mp3 \\
    -t 60 -c:v copy -c:a aac -shortest \\
    -af "afade=..." -movflags "+faststart" output.mp4

改善版:

  ffmpeg -i concat.mp4 -stream_loop -1 -i bgm.mp3 \\
    -c:v copy -c:a aac -q:a 8 \\
    -map 0:v:0 -map 1:a:0 -t 60 \\
    -af "afade=..." \\
    -movflags "+faststart+empty_moov" \\
    -fflags +genpts output.mp4

変更点:
  1. -c:a aac -q:a 8 : 品質を保ちつつ高速化
  2. -map 0:v:0 -map 1:a:0 : ストリーム明示指定で同期改善
  3. -movflags "+faststart+empty_moov" : MP4 最適化
  4. -fflags +genpts : PTS 自動生成

期待効果: 20-30% の高速化
""")
